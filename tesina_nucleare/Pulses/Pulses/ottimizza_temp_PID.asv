function ottimizza_temp_PID(temp_core_data, temp_omp_data, temp_tar_data, ne_data, P_tot, Zeff_data)
    
    % Costante cz e volume V
    cz = 1.0;  % Aggiungi la costante appropriata
    V = 80;  % Volume, modifica con il valore reale
    % Parametri di tempo
    t = temp_core_data.Time;  % Tempo del tuo timeseries
    dt = t(2) - t(1);
 
    % Range PID da esplorare
    Kp_vals = linspace(0.1, 50, 10);
    Ki_vals = linspace(0, 20, 5);
    Kd_vals = linspace(0, 10, );
 
 
    best_J = Inf;
    best_K = [0 0 0];
 
    for Kp = Kp_vals
        for Ki = Ki_vals
            for Kd = Kd_vals
                % Chiama la funzione di simulazione per calcolare J
                J = simula_temp_PID(Kp, Ki, Kd, 300, temp_core_data, temp_omp_data, temp_tar_data, ne_data, Zeff_data, cz, V, t, P_tot);
                if J < best_J
                    best_J = J;
                    best_K = [Kp, Ki, Kd];
                end
            end
        end
    end
 
    fprintf('=== PID Ottimizzato per la Temperatura ===\n');
    fprintf('Kp = %.3f\nKi = %.3f\nKd = %.3f\nCosto J = %.4f\n', ...
        best_K(1), best_K(2), best_K(3), best_J);
end

function J = simula_temp_PID(Kp, Ki, Kd, tau, temp_core_data, temp_omp_data, temp_tar_data, ne_data, Zeff_data, cz, V, t, P_tot)
    dt = t(2) - t(1);
    E = zeros(size(t));  % Energia
    e_int = 0;
    e_prev = 0;
    y = zeros(size(t));

    % Inizializzazione della variabile per l'energia
    % Interpolazione
    P_cond = P_tot.Data;
    tempo_cond = P_tot.Time;
    P_cond_interp = interp1(tempo_cond, P_cond, t, 'linear', 'extrap');
    T_tar_interp = interp1(temp_tar_data.Time, temp_tar_data.Data, t, 'linear', 'extrap');


    Pnbi = P_cond_interp;  % Energia da nbi
    P_brem = zeros(size(t));  % Energia da brem, calcolata
    P_imp = zeros(size(t));  % Energia da imp, calcolata
 
    for i = 2:length(t)
        % Trova l'indice più vicino per il tempo t(i)
        [~, idx_core] = min(abs(temp_core_data.Time - t(i)));
        [~, idx_omp] = min(abs(temp_omp_data.Time - t(i)));
        T_tar_value = T_tar_interp(i);  % Utilizza il valore interpolato direttamente
        [~, idx_ne] = min(abs(ne_data.Time - t(i)));  % Densità elettronica
        [~, idx_Zeff] = min(abs(Zeff_data.Time - t(i)));  % Effettivo Z
 
        % Calcola le potenze
        P_brem(i) = (1.7e-38) * Zeff_data.Data(idx_Zeff)^2 * ne_data.Data(idx_ne)^2 * sqrt(temp_core_data.Data(idx_core)) * V;
        P_imp(i) = cz * ne_data.Data(idx_ne)^2 * 1e-34;
 
        % Confronta la temperatura simulata con i dati reali
        e_core = temp_core_data.Data(idx_core) - E(i-1);  % errore core
        e_omp = temp_omp_data.Data(idx_omp) - E(i-1);  % errore omp
        e_tar = T_tar_value - E(i-1);  % errore target
 
        % Calcola l'errore totale
        e = e_core + e_omp + e_tar;
 
        e_int = e_int + e * dt;  % Aggiorna l'errore integrato
        e_der = (e - e_prev) / dt;  % Derivata dell'errore
 
        % Calcola la risposta del PID
        S = Kp * e + Ki * e_int + Kd * e_der;
 
        % Modello dinamico: dE = -(1/tau) * E + Pnbi - P_brem - P_imp
        E_dot = -(1/tau) * E(i-1) + Pnbi(i) - P_brem(i) - P_imp(i);
        % fprintf("dimensioni E %d\tdimensioni E_dot %d \n", E, E_dot);
        E(i) = E(i-1) + E_dot * dt;  % Aggiorna l'energia
 
        y(i) = E(i);  % Salva il valore di output
        e_prev = e;  % Memorizza l'errore precedente
    end
 

    % Calcola la funzione costo in base all'errore
    ref = temp_core_data.Data(end);  % riferimento finale dal dato reale
    ess = abs(y(end) - ref);  % errore a regime
    overshoot = max(0, (max(y) - ref) * 100);
    idx_Ts = find(abs(y - ref) > 0.05 * ref, 1, 'last');
    if ~isempty(idx_Ts)
        Ts = t(idx_Ts);
    else
        Ts = 0;
    end
 
    % Funzione di costo J (basata su overshoot, Ts e errore a regime)
    J = 1 * overshoot + 1 * Ts + 10 * ess;
end